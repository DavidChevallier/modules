"""
This file was generated by the KCL auto-gen tool. DO NOT EDIT.
Editing this file might prove futile when you re-run the KCL auto-gen generate command.
"""
import regex
import k8s.apimachinery.pkg.apis.meta.v1
_regex_match = regex.match


schema NodePool:
    r"""
    NodePool is the Schema for the NodePools API

    Attributes
    ----------
    apiVersion : str, default is "karpenter.sh/v1", required
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind : str, default is "NodePool", required
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata : v1.ObjectMeta, default is Undefined, optional
        metadata
    spec : KarpenterShV1NodePoolSpec, default is Undefined, required
        spec
    status : KarpenterShV1NodePoolStatus, default is Undefined, optional
        status
    """


    apiVersion: "karpenter.sh/v1" = "karpenter.sh/v1"

    kind: "NodePool" = "NodePool"

    metadata?: v1.ObjectMeta

    spec: KarpenterShV1NodePoolSpec

    status?: KarpenterShV1NodePoolStatus


schema KarpenterShV1NodePoolSpec:
    r"""
    NodePoolSpec is the top level nodepool specification. Nodepools
    launch nodes in response to pods that are unschedulable. A single nodepool
    is capable of managing a diverse set of nodes. Node properties are determined
    from a combination of nodepool and pod scheduling constraints.

    Attributes
    ----------
    limits : {str:int | str}, default is Undefined, optional
        Limits define a set of bounds for provisioning capacity.
    weight : int, default is Undefined, optional
        Weight is the priority given to the nodepool during scheduling. A higher
        numerical weight indicates that this nodepool will be ordered
        ahead of other nodepools with lower weights. A nodepool with no weight
        will be treated as if it is a nodepool with a weight of 0.
    disruption : KarpenterShV1NodePoolSpecDisruption, default is Undefined, optional
        disruption
    template : KarpenterShV1NodePoolSpecTemplate, default is Undefined, required
        template
    """


    limits?: {str:int | str}

    weight?: int

    disruption?: KarpenterShV1NodePoolSpecDisruption

    template: KarpenterShV1NodePoolSpecTemplate


    check:
        all _, limits in limits { _regex_match(str(limits), r"^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$") if limits } if limits
        weight <= 100 if weight not in [None, Undefined]
        weight >= 1 if weight not in [None, Undefined]


schema KarpenterShV1NodePoolSpecDisruption:
    r"""
    Disruption contains the parameters that relate to Karpenter's disruption logic

    Attributes
    ----------
    budgets : [KarpenterShV1NodePoolSpecDisruptionBudgetsItems0], default is [{"nodes": {"value": "10%", "x-order": 0}}], optional
        Budgets is a list of Budgets.
        If there are multiple active budgets, Karpenter uses
        the most restrictive value. If left undefined,
        this will default to one budget with a value to 10%.
    consolidateAfter : str, default is Undefined, required
        ConsolidateAfter is the duration the controller will wait
        before attempting to terminate nodes that are underutilized.
        Refer to ConsolidationPolicy for how underutilization is considered.
    consolidationPolicy : str, default is "WhenEmptyOrUnderutilized", optional
        ConsolidationPolicy describes which nodes Karpenter can disrupt through its consolidation
        algorithm. This policy defaults to "WhenEmptyOrUnderutilized" if not specified
    """


    budgets?: [KarpenterShV1NodePoolSpecDisruptionBudgetsItems0] = [{"nodes": {"value": "10%", "x-order": 0}}]

    consolidateAfter: str

    consolidationPolicy?: "WhenEmpty" | "WhenEmptyOrUnderutilized" = "WhenEmptyOrUnderutilized"


    check:
        len(budgets) <= 50 if budgets
        _regex_match(str(consolidateAfter), r"^(([0-9]+(s|m|h))+)|(Never)$")


schema KarpenterShV1NodePoolSpecDisruptionBudgetsItems0:
    r"""
    Budget defines when Karpenter will restrict the
    number of Node Claims that can be terminating simultaneously.

    Attributes
    ----------
    duration : str, default is Undefined, optional
        Duration determines how long a Budget is active since each Schedule hit.
        Only minutes and hours are accepted, as cron does not work in seconds.
        If omitted, the budget is always active.
        This is required if Schedule is set.
        This regex has an optional 0s at the end since the duration.String() always adds
        a 0s at the end.
    nodes : str, default is "10%", required
        Nodes dictates the maximum number of NodeClaims owned by this NodePool
        that can be terminating at once. This is calculated by counting nodes that
        have a deletion timestamp set, or are actively being deleted by Karpenter.
        This field is required when specifying a budget.
        This cannot be of type intstr.IntOrString since kubebuilder doesn't support pattern
        checking for int nodes for IntOrString nodes.
        Ref: https://github.com/kubernetes-sigs/controller-tools/blob/55efe4be40394a288216dab63156b0a64fb82929/pkg/crd/markers/validation.go#L379-L388
    reasons : [str], default is Undefined, optional
        Reasons is a list of disruption methods that this budget applies to. If Reasons is not set, this budget applies to all methods.
        Otherwise, this will apply to each reason defined.
        allowed reasons are Underutilized, Empty, and Drifted.
    schedule : str, default is Undefined, optional
        Schedule specifies when a budget begins being active, following
        the upstream cronjob syntax. If omitted, the budget is always active.
        Timezones are not supported.
        This field is required if Duration is set.
    """


    duration?: str

    nodes: str = "10%"

    reasons?: [str]

    schedule?: str


    check:
        _regex_match(str(duration), r"^((([0-9]+(h|m))|([0-9]+h[0-9]+m))(0s)?)$") if duration
        _regex_match(str(nodes), r"^((100|[0-9]{1,2})%|[0-9]+)$")
        _regex_match(str(schedule), r"^(@(annually|yearly|monthly|weekly|daily|midnight|hourly))|((.+)\s(.+)\s(.+)\s(.+)\s(.+))$") if schedule


schema KarpenterShV1NodePoolSpecTemplate:
    r"""
    Template contains the template of possibilities for the provisioning logic to launch a NodeClaim with.
    NodeClaims launched from this NodePool will often be further constrained than the template specifies.

    Attributes
    ----------
    metadata : KarpenterShV1NodePoolSpecTemplateMetadata, default is Undefined, optional
        metadata
    spec : KarpenterShV1NodePoolSpecTemplateSpec, default is Undefined, required
        spec
    """


    metadata?: KarpenterShV1NodePoolSpecTemplateMetadata

    spec: KarpenterShV1NodePoolSpecTemplateSpec


schema KarpenterShV1NodePoolSpecTemplateMetadata:
    r"""
    karpenter sh v1 node pool spec template metadata

    Attributes
    ----------
    annotations : {str:str}, default is Undefined, optional
        Annotations is an unstructured key value map stored with a resource that may be
        set by external tools to store and retrieve arbitrary metadata. They are not
        queryable and should be preserved when modifying objects.
        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
    labels : {str:str}, default is Undefined, optional
        Map of string keys and values that can be used to organize and categorize
        (scope and select) objects. May match selectors of replication controllers
        and services.
        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
    """


    annotations?: {str:str}

    labels?: {str:str}


    check:
        all _, labels in labels { len(labels) <= 63 if labels not in [None, Undefined] } if labels
        all _, labels in labels { _regex_match(str(labels), r"^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$") if labels } if labels


schema KarpenterShV1NodePoolSpecTemplateSpec:
    r"""
    NodeClaimTemplateSpec describes the desired state of the NodeClaim in the Nodepool
    NodeClaimTemplateSpec is used in the NodePool's NodeClaimTemplate, with the resource requests omitted since
    users are not able to set resource requests in the NodePool.

    Attributes
    ----------
    expireAfter : str, default is "720h", optional
        ExpireAfter is the duration the controller will wait
        before terminating a node, measured from when the node is created. This
        is useful to implement features like eventually consistent node upgrade,
        memory leak protection, and disruption testing.
    requirements : [KarpenterShV1NodePoolSpecTemplateSpecRequirementsItems0], default is Undefined, required
        Requirements are layered with GetLabels and applied to every node.
    startupTaints : [KarpenterShV1NodePoolSpecTemplateSpecStartupTaintsItems0], default is Undefined, optional
        StartupTaints are taints that are applied to nodes upon startup which are expected to be removed automatically
        within a short period of time, typically by a DaemonSet that tolerates the taint. These are commonly used by
        daemonsets to allow initialization and enforce startup ordering.  StartupTaints are ignored for provisioning
        purposes in that pods are not required to tolerate a StartupTaint in order to have nodes provisioned for them.
    taints : [KarpenterShV1NodePoolSpecTemplateSpecTaintsItems0], default is Undefined, optional
        Taints will be applied to the NodeClaim's node.
    terminationGracePeriod : str, default is Undefined, optional
        TerminationGracePeriod is the maximum duration the controller will wait before forcefully deleting the pods on a node, measured from when deletion is first initiated.


        Warning: this feature takes precedence over a Pod's terminationGracePeriodSeconds value, and bypasses any blocked PDBs or the karpenter.sh/do-not-disrupt annotation.


        This field is intended to be used by cluster administrators to enforce that nodes can be cycled within a given time period.
        When set, drifted nodes will begin draining even if there are pods blocking eviction. Draining will respect PDBs and the do-not-disrupt annotation until the TGP is reached.


        Karpenter will preemptively delete pods so their terminationGracePeriodSeconds align with the node's terminationGracePeriod.
        If a pod would be terminated without being granted its full terminationGracePeriodSeconds prior to the node timeout,
        that pod will be deleted at T = node timeout - pod terminationGracePeriodSeconds.


        The feature can also be used to allow maximum time limits for long-running jobs which can delay node termination with preStop hooks.
        If left undefined, the controller will wait indefinitely for pods to be drained.
    nodeClassRef : KarpenterShV1NodePoolSpecTemplateSpecNodeClassRef, default is Undefined, required
        node class ref
    """


    expireAfter?: str = "720h"

    requirements: [KarpenterShV1NodePoolSpecTemplateSpecRequirementsItems0]

    startupTaints?: [KarpenterShV1NodePoolSpecTemplateSpecStartupTaintsItems0]

    taints?: [KarpenterShV1NodePoolSpecTemplateSpecTaintsItems0]

    terminationGracePeriod?: str

    nodeClassRef: KarpenterShV1NodePoolSpecTemplateSpecNodeClassRef


    check:
        _regex_match(str(expireAfter), r"^(([0-9]+(s|m|h))+)|(Never)$") if expireAfter
        len(requirements) <= 100
        _regex_match(str(terminationGracePeriod), r"^([0-9]+(s|m|h))+$") if terminationGracePeriod


schema KarpenterShV1NodePoolSpecTemplateSpecNodeClassRef:
    r"""
    NodeClassRef is a reference to an object that defines provider specific configuration

    Attributes
    ----------
    group : str, default is Undefined, required
        API version of the referent
    kind : str, default is Undefined, required
        Kind of the referent; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
    name : str, default is Undefined, required
        Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
    """


    group: str

    kind: str

    name: str


    check:
        _regex_match(str(group), r"^[^/]*$")


schema KarpenterShV1NodePoolSpecTemplateSpecRequirementsItems0:
    r"""
    A node selector requirement with min values is a selector that contains values, a key, an operator that relates the key and values
    and minValues that represent the requirement to have at least that many values.

    Attributes
    ----------
    key : str, default is Undefined, required
        The label key that the selector applies to.
    minValues : int, default is Undefined, optional
        This field is ALPHA and can be dropped or replaced at any time
        MinValues is the minimum number of unique values required to define the flexibility of the specific requirement.
    operator : str, default is Undefined, required
        Represents a key's relationship to a set of values.
        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    values : [str], default is Undefined, optional
        An array of string values. If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.
    """


    key: str

    minValues?: int

    operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt"

    values?: [str]


    check:
        len(key) <= 316
        _regex_match(str(key), r"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*(\/))?([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]$")
        minValues <= 50 if minValues not in [None, Undefined]
        minValues >= 1 if minValues not in [None, Undefined]
        len(values) <= 63 if values
        _regex_match(str(values), r"^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$") if values


schema KarpenterShV1NodePoolSpecTemplateSpecStartupTaintsItems0:
    r"""
    The node this Taint is attached to has the "effect" on
    any pod that does not tolerate the Taint.

    Attributes
    ----------
    effect : str, default is Undefined, required
        Required. The effect of the taint on pods
        that do not tolerate the taint.
        Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
    key : str, default is Undefined, required
        Required. The taint key to be applied to a node.
    timeAdded : str, default is Undefined, optional
        TimeAdded represents the time at which the taint was added.
        It is only written for NoExecute taints.
    value : str, default is Undefined, optional
        The taint value corresponding to the taint key.
    """


    effect: "NoSchedule" | "PreferNoSchedule" | "NoExecute"

    key: str

    timeAdded?: str

    value?: str


    check:
        len(key) >= 1
        _regex_match(str(key), r"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*(\/))?([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]$")
        _regex_match(str(value), r"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*(\/))?([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]$") if value


schema KarpenterShV1NodePoolSpecTemplateSpecTaintsItems0:
    r"""
    The node this Taint is attached to has the "effect" on
    any pod that does not tolerate the Taint.

    Attributes
    ----------
    effect : str, default is Undefined, required
        Required. The effect of the taint on pods
        that do not tolerate the taint.
        Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
    key : str, default is Undefined, required
        Required. The taint key to be applied to a node.
    timeAdded : str, default is Undefined, optional
        TimeAdded represents the time at which the taint was added.
        It is only written for NoExecute taints.
    value : str, default is Undefined, optional
        The taint value corresponding to the taint key.
    """


    effect: "NoSchedule" | "PreferNoSchedule" | "NoExecute"

    key: str

    timeAdded?: str

    value?: str


    check:
        len(key) >= 1
        _regex_match(str(key), r"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*(\/))?([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]$")
        _regex_match(str(value), r"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*(\/))?([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]$") if value


schema KarpenterShV1NodePoolStatus:
    r"""
    NodePoolStatus defines the observed state of NodePool

    Attributes
    ----------
    conditions : [KarpenterShV1NodePoolStatusConditionsItems0], default is Undefined, optional
        Conditions contains signals for health and readiness
    resources : {str:int | str}, default is Undefined, optional
        Resources is the list of resources that have been provisioned.
    """


    conditions?: [KarpenterShV1NodePoolStatusConditionsItems0]

    resources?: {str:int | str}


    check:
        all _, resources in resources { _regex_match(str(resources), r"^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$") if resources } if resources


schema KarpenterShV1NodePoolStatusConditionsItems0:
    r"""
    Condition aliases the upstream type and adds additional helper methods

    Attributes
    ----------
    lastTransitionTime : str, default is Undefined, required
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    message : str, default is Undefined, required
        message is a human readable message indicating details about the transition.
        This may be an empty string.
    observedGeneration : int, default is Undefined, optional
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
    reason : str, default is Undefined, required
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
    status : str, default is Undefined, required
        status of the condition, one of True, False, Unknown.
    $type : str, default is Undefined, required
        type of condition in CamelCase or in foo.example.com/CamelCase.
        ---
        Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
        useful (see .node.status.conditions), the ability to deconflict is important.
        The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    """


    lastTransitionTime: str

    message: str

    observedGeneration?: int

    reason: str

    status: "True" | "False" | "Unknown"

    $type: str


    check:
        len(message) <= 32768
        observedGeneration >= 0 if observedGeneration not in [None, Undefined]
        len(reason) <= 1024
        len(reason) >= 1
        _regex_match(str(reason), r"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$")
        len($type) <= 316
        _regex_match(str($type), r"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$")


